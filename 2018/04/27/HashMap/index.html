<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="jdk," />










<meta name="description" content="如果你说你不了解 HashMap，那么你是一个合格的程序员吗？如果你没有仔细阅读过JDK 1.8中的 HashMap 你敢说自己真的尝试过深入了解 Java 吗？">
<meta name="keywords" content="jdk">
<meta property="og:type" content="article">
<meta property="og:title" content="你真的读懂了Java的HashMap了吗？">
<meta property="og:url" content="http://yoursite.com/2018/04/27/HashMap/index.html">
<meta property="og:site_name" content="Seventeen">
<meta property="og:description" content="如果你说你不了解 HashMap，那么你是一个合格的程序员吗？如果你没有仔细阅读过JDK 1.8中的 HashMap 你敢说自己真的尝试过深入了解 Java 吗？">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-05-11T08:52:12.323Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="你真的读懂了Java的HashMap了吗？">
<meta name="twitter:description" content="如果你说你不了解 HashMap，那么你是一个合格的程序员吗？如果你没有仔细阅读过JDK 1.8中的 HashMap 你敢说自己真的尝试过深入了解 Java 吗？">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/04/27/HashMap/"/>





  <title>你真的读懂了Java的HashMap了吗？ | Seventeen</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?e343ffb916903244dcee7c16ddbe30f4";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Seventeen</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/27/HashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="花栗鼠">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Seventeen">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">你真的读懂了Java的HashMap了吗？</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-27T18:03:33+08:00">
                2018-04-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/代码/" itemprop="url" rel="index">
                    <span itemprop="name">代码</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>如果你说你不了解 HashMap，那么你是一个合格的程序员吗？如果你没有仔细阅读过JDK 1.8中的 HashMap 你敢说自己真的尝试过深入了解 Java 吗？</p>
<a id="more"></a>
<h4 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h4><p>本文以jdk1.8 为例<br>Java 的 HashMap 总的来看，是以数组加链表的方式组成，采用拉链法解决 hash 冲突（对应的还有开放地址法），当链表长度大于某个定值时（值为8）转变为红黑树，当容量大于一定数量时进行 rehash，HashMap 并非线程安全，在多线程环境中容易出错。以下我们根据 jdk1.8 中 HashMap 的源码来共同学习其中的实现。注意：本文不会描述其中红黑树的实现（一是由于红黑树复杂，本文会丢失重点，其二是理解红黑树需要认真看算法书）。</p>
<h4 id="几个重要的静态常量"><a href="#几个重要的静态常量" class="headerlink" title="几个重要的静态常量"></a>几个重要的静态常量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;</span><br><span class="line">static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</span><br><span class="line">static final float DEFAULT_LOAD_FACTOR = 0.75f;</span><br><span class="line">static final int TREEIFY_THRESHOLD = 8;</span><br><span class="line">static final int UNTREEIFY_THRESHOLD = 6;</span><br><span class="line">static final int MIN_TREEIFY_CAPACITY = 64;</span><br></pre></td></tr></table></figure>
<p>这几个静态常量有着重要意义，根据命名可以知道：</p>
<ul>
<li>第一行代码表示初始数组大小 16（或称为槽的大小）；</li>
<li>第二行代码表示 HashMap 的最大容量 2^30 = 1 073 741 824；</li>
<li>第三行代码表示初始化负载因子为 0.75 （负载因子 = 容量 / 槽的大小）；</li>
<li>第四行代码表示将链表转换为红黑树的阈值；</li>
<li>第五行代码表示将红黑树节点变为 6 时转换回链表；</li>
<li>第六行代码表示转换为树时的最小元素个数，即小于该数时并不会转换为红黑树。</li>
</ul>
<h4 id="Node-节点实现"><a href="#Node-节点实现" class="headerlink" title="Node 节点实现"></a>Node 节点实现</h4><p>Node 是存放 key-value 的对象，其实现了 Map.entry() 接口，该接口定义了一些常用的方法和比较器，Node 是链表的基本组成元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">       final int hash;</span><br><span class="line">       final K key;</span><br><span class="line">       V value;</span><br><span class="line">       Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">       Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">           this.hash = hash;</span><br><span class="line">           this.key = key;</span><br><span class="line">           this.value = value;</span><br><span class="line">           this.next = next;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       public final K getKey()        &#123; return key; &#125;</span><br><span class="line">       public final V getValue()      &#123; return value; &#125;</span><br><span class="line">       public final String toString() &#123; return key + &quot;=&quot; + value; &#125;</span><br><span class="line"></span><br><span class="line">       public final int hashCode() &#123;</span><br><span class="line">           return Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       public final V setValue(V newValue) &#123;</span><br><span class="line">           V oldValue = value;</span><br><span class="line">           value = newValue;</span><br><span class="line">           return oldValue;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       public final boolean equals(Object o) &#123;</span><br><span class="line">           if (o == this)</span><br><span class="line">               return true;</span><br><span class="line">           if (o instanceof Map.Entry) &#123;</span><br><span class="line">               Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">               if (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                   Objects.equals(value, e.getValue()))</span><br><span class="line">                   return true;</span><br><span class="line">           &#125;</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="hash-算法"><a href="#hash-算法" class="headerlink" title="hash 算法"></a>hash 算法</h4><p>Node 对象重写了 hashCode 和 equals 方法，第二行的 hash 为 key 值的hash，其通过 hash() 方法计算，该方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码说明了 hash 值的计算方法，为了尽量的使 key 散列在不同的槽位上，该方法对 key 对象本身的 hashCode 做了些改变，上面这段代码也叫做“扰动函数”，其目的就是为了更均匀的散列 key。试想一下，如果只返回 key 对象的 hashCode, hashCode 的值为 int，其本身大概有 40 亿的值，若要将其均匀的散列，需要我们的槽位大于 40 亿，这样的数组太占内存。所以散列值会对数组长度取模，在源码实现中使用 &amp; 操作代替取模，这也是数组长度为何需要为 2 的 n 次幂的一个原因。取数组的下标如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int n = tab.length;</span><br><span class="line">int index = (n-1) &amp; hash</span><br></pre></td></tr></table></figure></p>
<p>大致意思如上代码所示，由于数组长度始终为 2 的 n 次幂，所以 n-1 的低位全部为 1，也即是我们得到的 index 其实就是 hash 值的低位。 例如数组大小被初始化为 16（DEFAULT_INITIAL_CAPACITY），那么其长度减 1 得到的二进制表示为 0000 1111，可以看到任何数与它进行 &amp; 操作后都只会得到原数字的最后 4 位。这时就会出现一个问题，假如两个 hashCode 为 01AC 0000 和 AB71 0000，这时取最低的位数为数组 index 的值，那么就会发生 hash 冲突，分布不均匀，这时候上述的“扰动函数”就体现了其作用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">以 hashCode 为 01AC 0000 为例</span><br><span class="line">0000 0001 1010 1100 0000 0000 0000 0000 </span><br><span class="line">---------------------------------------无符号右移 16 位</span><br><span class="line">0000 0000 0000 0000 0000 0001 1010 1100</span><br><span class="line">--------------------------------------- h^(h&gt;&gt;&gt;16) </span><br><span class="line">0000 0001 1010 1100 0000 0001 1010 1100</span><br><span class="line">--------------------------------------- 与 16-1 进行 &amp; 操作</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 1111</span><br><span class="line">---------------------------------------</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 1100 </span><br><span class="line">同理可推断出hashCode 为 AB71 0000 的结果为 0001</span><br></pre></td></tr></table></figure></p>
<p>可以看到，所谓的“扰动函数”其实就是加大随机性，使用 hashCode 的低 16 位与高 16 位进行 ^ 操作，使其在计算数组 index 的时候尽量分散。</p>
<h4 id="指定数组大小计算"><a href="#指定数组大小计算" class="headerlink" title="指定数组大小计算"></a>指定数组大小计算</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static final int tableSizeFor(int cap) &#123;</span><br><span class="line">    int n = cap - 1;</span><br><span class="line">    n |= n &gt;&gt;&gt; 1;</span><br><span class="line">    n |= n &gt;&gt;&gt; 2;</span><br><span class="line">    n |= n &gt;&gt;&gt; 4;</span><br><span class="line">    n |= n &gt;&gt;&gt; 8;</span><br><span class="line">    n |= n &gt;&gt;&gt; 16;</span><br><span class="line">    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码用于在初始化中指定初始数组大小时调用，其返回不小于指定 cap 的最小 2 的 n 次幂，如何理解这句话？为了方便 hash 值的计算（不止这一个原因，后面还会提到），我们规定数组大小为 2 的 n 次幂，所以当用户指定 HashMap 初始大小时，会进行一个转换，将其转换为不小于指定容量的最小 2 的 n 次幂，比如初始化大小为 18，那么返回 32， 初始化大小 65，返回 128。<br>我们根据代码来探究该算法的精妙之处：</p>
<ul>
<li>首先假设 cap 小于等于 0 的情况<br>此时 n 经 cap-1 后为负数，负数的最高位为1（符号位）,那么不管以如何移动，最后与一个负数进行 | 操作时始终为负数，所以最后会返回 1。</li>
<li>假如 cap 为 1<br>此时上述所有操作都为 0，因为 0 包括符号位在内的二进制表示都为 0（32 个 0），最后会返回 n+1，即是返回 1。</li>
<li>假如 cap 大于 1</li>
</ul>
<p>此时得到的 n 二进制表示中，肯定有一位数为 1， 例如得到的为<strong> 0000 001X XXXX XXXX </strong>，将该数字无符号右移一位得到:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000 0001 XXXX XXXX</span><br></pre></td></tr></table></figure></p>
<p>将得到的数字与原数进行 | 操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000 0011 XXXX XXXX</span><br></pre></td></tr></table></figure></p>
<p>我们可以发现该操作将原数字的次低位变为了 1。<br>同理进行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n |= n &gt;&gt;&gt; 2;</span><br></pre></td></tr></table></figure></p>
<p>得到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000 0011 11XX XXXX</span><br></pre></td></tr></table></figure></p>
<p>相应的执行后续代码，我们可以发现，该算法将数字不为 0 的最高位以后全都变为 1。此时在得到的结果上加 1 就得到了最小 2 的 n 次幂。n = cap-1 的作用是为了防止该数字本身就是 2 的 n 次幂，若不进行减 1 操作，将会返回该数字的两倍。</p>
<h4 id="HashMap-的构造方法"><a href="#HashMap-的构造方法" class="headerlink" title="HashMap 的构造方法"></a>HashMap 的构造方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    this.loadFactor = loadFactor;</span><br><span class="line">    this.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public HashMap(int initialCapacity) &#123;</span><br><span class="line">    this(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public HashMap() &#123;</span><br><span class="line">    this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">    this.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 HashMap 初始化的时候可以自定义初始容量和负载因子，一般在我们可以估算HashMap可能大小时，自定义初始容量可以避免扩容带来的性能开销。注意第四个构造函数，它允许传入一个 map。具体实现如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123;</span><br><span class="line">    int s = m.size();</span><br><span class="line">    if (s &gt; 0) &#123;</span><br><span class="line">        if (table == null) &#123; // pre-size</span><br><span class="line">            float ft = ((float)s / loadFactor) + 1.0F;</span><br><span class="line">            int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (int)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            if (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, false, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中的思想很简单，初始化一个合适大小的 table 数组，然后将 key-value 依次放入。</p>
<h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    return (e = getNode(hash(key), key)) == null ? null : e.value;</span><br><span class="line">&#125;</span><br><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (first = tab[(n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">        if (first.hash == hash &amp;&amp; // always check first node</span><br><span class="line">            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            return first;</span><br><span class="line">        if ((e = first.next) != null) &#123;</span><br><span class="line">            if (first instanceof TreeNode)</span><br><span class="line">                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            do &#123;</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    return e;</span><br><span class="line">            &#125; while ((e = e.next) != null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>hash 值的计算我们在前面已经分析了，get 主要的实现逻辑在 getNode(int hash, Object key) 中，头结点通过 tab[(n-1)&amp;hash] 取得，具体计算原理详见前面的 hash 算法。其实就是通过 hash 值找到数组下标后取得 Node 对象。最后对这个包括 first 结点的链表或者红黑树进行遍历，找到 key 相同的结点返回 value。</p>
<h4 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">               boolean evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">        tab[i] = newNode(hash, key, value, null);</span><br><span class="line">    else &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        if (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        else if (p instanceof TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">        else &#123;</span><br><span class="line">            for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                if ((e = p.next) == null) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, null);</span><br><span class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    break;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (e != null) &#123; // existing mapping for key</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    if (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>put 的逻辑相较于 get 复杂，但是弄懂每一行代码的意思也比较容易理解。首先根据 key 的hash 值定位数组下标，如果该位置为空那么直接 new 一个包含需要插入 key-value 的 Node 对象。若该位置不为空，那么取得头结点，按照其属于链表还是红黑树执行相应的插入操作：如果 key 已经存在，则在相应位置直接替换 value，若不存在则在链表末尾或者红黑树相应位置插入新的 Node 对象。其中还有些细节，比如第 22-23 行，计算链表的长度大于规定的 TREEIFY_THRESHOLD - 1 后就会将链表包装为红黑树。41-42 行表示如果大小超过 threshold 就执行扩容操作。如果元素个数大于 threshold (= factor * capacity) 那么执行扩容操作。<br>由 put 和 get 的逻辑中，我们发现其实 HashMap 是允许存放的对象为 null。</p>
<h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h4><p>remove 方法与 put 方法逻辑相似，不同的是 remove 不会产生 rehash 操作。</p>
<h4 id="扩容与-reHash"><a href="#扩容与-reHash" class="headerlink" title="扩容与 reHash"></a>扩容与 reHash</h4><p>其中的 resize 方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">    int oldThr = threshold;</span><br><span class="line">    int newCap, newThr = 0;</span><br><span class="line">    if (oldCap &gt; 0) &#123;</span><br><span class="line">        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            return oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">    &#125;</span><br><span class="line">    else if (oldThr &gt; 0) // initial capacity was placed in threshold</span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    else &#123;               // zero initial threshold signifies using defaults</span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    if (newThr == 0) &#123;</span><br><span class="line">        float ft = (float)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (int)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    if (oldTab != null) &#123;</span><br><span class="line">        for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">                oldTab[j] = null;</span><br><span class="line">                if (e.next == null)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">                else if (e instanceof TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                else &#123; // preserve order</span><br><span class="line">                    Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    do &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">                            if (loTail == null)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            else</span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123;</span><br><span class="line">                            if (hiTail == null)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            else</span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; while ((e = next) != null);</span><br><span class="line">                    if (loTail != null) &#123;</span><br><span class="line">                        loTail.next = null;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (hiTail != null) &#123;</span><br><span class="line">                        hiTail.next = null;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法不仅仅在扩容的时候用到，注意上面分析过的 putVal 方法，其中如果初始表为空也会调用该方法。该方法的思想很简单，就是将数组扩大两倍，然后把所有元素的引用指向新的数组。最精妙的实现在于 resize 的时候，重新计算元素位置，该方法并未直接使用 hash &amp; (tab.length -1) 这种方法实现。而是根据 bit =  hash &amp; tab.length 的结果来决定，如果 bit 为 0，则直接在新数组的原下标（旧数组中该元素的数组下标）添加，如果为 1，则在 newTab[j +oldCap] 位置添加。怎么计算的呢？ 通过我们前面的分析已经知道，hash 值通过 key 的hashCode 而得到，是 Node 对象的一个 32 位 int 值，通过 hash &amp; (tab.length -1) 这种方法得到数组下标，那么储存在同一位置的元素 key 的 hash 值有两种情况，第 n （= log(capacity)+1）位为 0 或者 1。如果 n 为 0，那么计算 hash &amp; (newTab.length - 1) 的时候就是同一个值，如果 n 为 1，那么计算 hash &amp; (newTab.length - 1) 的值就为就数组的大小加上以前的下标。这是因为数组长度始终为 2 的 n 次幂，所以 tab.length 的二进制除了符号位只有一个 1，而tab.length -1  则后几位全部为 1，利用这个特性可以轻松的算出我们需要的结果。<br>为何要弄得这么麻烦，看起来好像炫技多于实用，其实不然。试想一下，如果不使用上面这种算法，按照常规的思路，我们需要根据 putVal 的思路将 key-value 放到合适的位置，里面可能会涉及到树和链表的遍历，相对来说本方法省去了遍历的复杂度，提高了性能（每次都会更新高位和低位的尾节点，免去了每次遍历）。</p>
<h4 id="迭代器的实现"><a href="#迭代器的实现" class="headerlink" title="迭代器的实现"></a>迭代器的实现</h4><p>HashMap 中的迭代器以 HashIterator 这个抽象类为基类，主要包括 KeyIterator，ValueIterator，EntryItertator。其中 HashIterator 的代码实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">abstract class HashIterator &#123;</span><br><span class="line">    Node&lt;K,V&gt; next;        // next entry to return</span><br><span class="line">    Node&lt;K,V&gt; current;     // current entry</span><br><span class="line">    int expectedModCount;  // for fast-fail</span><br><span class="line">    int index;             // current slot</span><br><span class="line"></span><br><span class="line">    HashIterator() &#123;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">        Node&lt;K,V&gt;[] t = table;</span><br><span class="line">        current = next = null;</span><br><span class="line">        index = 0;</span><br><span class="line">        if (t != null &amp;&amp; size &gt; 0) &#123; // advance to first entry</span><br><span class="line">            do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final boolean hasNext() &#123;</span><br><span class="line">        return next != null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final Node&lt;K,V&gt; nextNode() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] t;</span><br><span class="line">        Node&lt;K,V&gt; e = next;</span><br><span class="line">        if (modCount != expectedModCount)</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        if (e == null)</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        if ((next = (current = e).next) == null &amp;&amp; (t = table) != null) &#123;</span><br><span class="line">            do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null);</span><br><span class="line">        &#125;</span><br><span class="line">        return e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final void remove() &#123;</span><br><span class="line">        Node&lt;K,V&gt; p = current;</span><br><span class="line">        if (p == null)</span><br><span class="line">            throw new IllegalStateException();</span><br><span class="line">        if (modCount != expectedModCount)</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        current = null;</span><br><span class="line">        K key = p.key;</span><br><span class="line">        removeNode(hash(key), key, null, false, false);</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中可以看到快速失败 fast-fail 的实现，快速失败是指集合类在迭代过程中，如果发现集合内容被改变时，会抛出异常（ConcurrentModificationException）。通过 modCount == expectedModCount 来判断，每次集合的内容改变时（增加，删除，修改）都会修改 modCount 的值，但是也注意这会有一个小 bug，如果 modCount 发生了改变，又同步修改了 expectedModCount 则会与预期不一样。重要的是该类并未对 modCount 做可见性假设（没有做同步的时候，其他线程修改后并没有及时同步到主内存），因此也有可能根本不会发现错误，所以不要依赖于该异常来编写代码，正确做法是依赖于它的特性来检测错误。</p>
<h4 id="非线程安全"><a href="#非线程安全" class="headerlink" title="非线程安全"></a>非线程安全</h4><p>HashMap 是一个非线程安全的容器，何为线程安全？</p>
<blockquote>
<p>当多个线程访问某个类时，不管运行时环境才用何种调度方法或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。</p>
</blockquote>
<p>这段定义出自《Java 并发编程实战》，如何构造一个线程安全的类是一个比较复杂的问题，但从其中需要遵循的一些要点，我们可以很轻易的得出 HashMap 是非线程安全的。比如并未对其中的开放域做任何同步处理，并未对数据的可见性以及竞态条件做任何假设等等。当多个线程同时操作同一个 HashMap 对象时，可能会出现各种不及预期的结果。例如数据丢失和数据不一致，由于主内存和工作内存的不同步，以及重排序的特点我们无法预料到操作的结果。但是多线程下的 put 和 resize 同时发生，真的会如前人所说的出现死循环吗？其实这个问题已经在 1.8 中得到了解决，1.8 中我们可以看到扩容过程中分为两条链表执行，且首尾节点的相对顺序不会改变，结果就是 <strong> 1.8 的 HashMap 在多线程环境中不会出现死循环 </strong>。<br>我感觉这个问题意义不大，因为官方文档已经说得清清楚楚，明明白白，HashMap 并非线程安全，如果要在多线程环境中使用 map，请考虑使用 Collections 做同步处理或者最好使用 ConcurrentHashMap。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/jdk/" rel="tag"># jdk</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/04/21/raft&paxos/" rel="next" title="Paxos 算法">
                <i class="fa fa-chevron-left"></i> Paxos 算法
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/05/08/Semaphore/" rel="prev" title="从一段代码说起 —— 信号量的内部机制">
                从一段代码说起 —— 信号量的内部机制 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">花栗鼠</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#总览"><span class="nav-number">1.</span> <span class="nav-text">总览</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#几个重要的静态常量"><span class="nav-number">2.</span> <span class="nav-text">几个重要的静态常量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Node-节点实现"><span class="nav-number">3.</span> <span class="nav-text">Node 节点实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hash-算法"><span class="nav-number">4.</span> <span class="nav-text">hash 算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#指定数组大小计算"><span class="nav-number">5.</span> <span class="nav-text">指定数组大小计算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap-的构造方法"><span class="nav-number">6.</span> <span class="nav-text">HashMap 的构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#get-方法"><span class="nav-number">7.</span> <span class="nav-text">get 方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#put-方法"><span class="nav-number">8.</span> <span class="nav-text">put 方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#remove"><span class="nav-number">9.</span> <span class="nav-text">remove</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#扩容与-reHash"><span class="nav-number">10.</span> <span class="nav-text">扩容与 reHash</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#迭代器的实现"><span class="nav-number">11.</span> <span class="nav-text">迭代器的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#非线程安全"><span class="nav-number">12.</span> <span class="nav-text">非线程安全</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">花栗鼠</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
